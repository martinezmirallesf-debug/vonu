"use client";

import React, { useEffect, useMemo, useRef, useState } from "react";

type Props = {
  value: string;
  className?: string;
  backgroundSrc?: string;

  // logical size (for drawing coordinates)
  width?: number; // default 1000
  height?: number; // default 600

  // Optional image overlay generated by IA
  boardImageB64?: string | null;
  boardImagePlacement?: { x: number; y: number; w: number; h: number } | null;
};

type ColorName = "white" | "yellow" | "cyan" | "pink" | "green" | "orange" | "red" | "blue" | "lightgreen" | "chalk";

const COLOR_MAP: Record<ColorName, string> = {
  white: "#e9efe9",
  yellow: "#ffe67a",
  cyan: "#79e6ff",
  pink: "#ff86c8",
  green: "#8cff9a",
  orange: "#ffb36b",
  red: "#ff6b6b",
  blue: "#79a7ff",
  lightgreen: "#9dffb8",
  chalk: "#f4f7f4",
};

function clamp(n: number, a: number, b: number) {
  return Math.max(a, Math.min(b, n));
}

// ================== SANITIZE ==================
function fixSuperscripts(s: string) {
  // a^2 -> a², a^3 -> a³ (solo casos comunes)
  return s
    .replace(/\^2/g, "²")
    .replace(/\^3/g, "³")
    // limpiar "( c )" -> "(c)"
    .replace(/\(\s+/g, "(")
    .replace(/\s+\)/g, ")")
    // limpiar espacios dobles
    .replace(/[ \t]{2,}/g, " ");
}

function sanitizeBoardValue(raw: string) {
  const s0 = (raw || "").replace(/\r\n/g, "\n");

  // si se cuela un JSON excalidraw gigante, fuera
  const tooJsony = s0.includes('"elements"') || s0.includes('"files"') || s0.includes('"appState"');
  if (tooJsony && !s0.trim().startsWith("{")) return "";

  // Limpieza LaTeX escapado típico
  let s = s0
    .replace(/\\\\\[/g, "")
    .replace(/\\\\\]/g, "")
    .replace(/\\\\\(/g, "(")
    .replace(/\\\\\)/g, ")")
    .replace(/\\\[/g, "")
    .replace(/\\\]/g, "")
    .replace(/\\\(/g, "(")
    .replace(/\\\)/g, ")");

  const lines = s.split("\n");
  const cleaned: string[] = [];

  for (const line of lines) {
    const t = line.trim();
    if (!t) continue;
    if (t.includes("{{IM") || t.includes("[[IM")) continue;
    if (t.toLowerCase().includes("placement")) continue;
    if (t.toLowerCase().includes("boardimage")) continue;
    if (t.toLowerCase().includes("b64")) continue;
    cleaned.push(line);
  }

  s = cleaned.join("\n").trim();
  s = fixSuperscripts(s);
  return s;
}

// ================== RNG / Chalk ==================
function hashStr(s: string) {
  let h = 2166136261;
  for (let i = 0; i < s.length; i++) {
    h ^= s.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}

function mulberry32(seed: number) {
  return function () {
    let t = (seed += 0x6d2b79f5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function drawChalkStroke(ctx: CanvasRenderingContext2D, fn: () => void) {
  ctx.save();
  ctx.globalAlpha = 0.93;
  ctx.shadowColor = "rgba(255,255,255,0.18)";
  ctx.shadowBlur = 1.0;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  fn();
  ctx.restore();
}

function drawWobblyLine(
  ctx: CanvasRenderingContext2D,
  x1: number,
  y1: number,
  x2: number,
  y2: number,
  color: string,
  lw: number,
  rng: () => number
) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  const dist = Math.hypot(dx, dy);
  const steps = clamp(Math.round(dist / 34), 4, 18);
  const nx = -dy / (dist || 1);
  const ny = dx / (dist || 1);
  const jitter = clamp(lw * 0.18, 0.45, 1.6);

  const drawOnce = (alpha: number, extra: number) => {
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = color;
    ctx.lineWidth = lw;
    drawChalkStroke(ctx, () => {
      ctx.beginPath();
      for (let i = 0; i <= steps; i++) {
        const tt = i / steps;
        const bx = x1 + dx * tt;
        const by = y1 + dy * tt;
        const wob = (rng() - 0.5) * (jitter + extra);
        const px = bx + nx * wob;
        const py = by + ny * wob;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.stroke();
    });
    ctx.restore();
  };

  drawOnce(0.92, 0);
  drawOnce(0.35, 0.5);
}

function drawArrow(ctx: CanvasRenderingContext2D, x1: number, y1: number, x2: number, y2: number, color: string, lw: number, rng: () => number) {
  drawWobblyLine(ctx, x1, y1, x2, y2, color, lw, rng);

  const ang = Math.atan2(y2 - y1, x2 - x1);
  const head = 10 + lw * 1.1;
  const ax1 = x2 - head * Math.cos(ang - Math.PI / 7);
  const ay1 = y2 - head * Math.sin(ang - Math.PI / 7);
  const ax2 = x2 - head * Math.cos(ang + Math.PI / 7);
  const ay2 = y2 - head * Math.sin(ang + Math.PI / 7);

  drawWobblyLine(ctx, x2, y2, ax1, ay1, color, lw, rng);
  drawWobblyLine(ctx, x2, y2, ax2, ay2, color, lw, rng);
}

function setChalkFont(ctx: CanvasRenderingContext2D, size: number) {
  ctx.font = `${size}px "Architects Daughter","Patrick Hand","Comic Sans MS",system-ui,-apple-system,Segoe UI,Roboto,Arial`;
}

function drawText(ctx: CanvasRenderingContext2D, text: string, x: number, y: number, size: number, color: string, rng: () => number) {
  ctx.save();
  ctx.textBaseline = "top";
  setChalkFont(ctx, size);
  ctx.fillStyle = color;
  ctx.globalAlpha = 0.96;
  ctx.shadowColor = "rgba(255,255,255,0.14)";
  ctx.shadowBlur = 0.9;

  const jx = (rng() - 0.5) * 0.55;
  const jy = (rng() - 0.5) * 0.55;
  ctx.fillText(text, x + jx, y + jy);
  ctx.restore();
}

function wrapText(ctx: CanvasRenderingContext2D, text: string, maxWidth: number) {
  const words = (text || "").split(/\s+/).filter(Boolean);
  if (!words.length) return [""];
  const out: string[] = [];
  let line = words[0];

  for (let i = 1; i < words.length; i++) {
    const test = line + " " + words[i];
    const w = ctx.measureText(test).width;
    if (w <= maxWidth) line = test;
    else {
      out.push(line);
      line = words[i];
    }
  }
  out.push(line);
  return out;
}

async function ensureFontsReady() {
  try {
    // @ts-ignore
    if (document?.fonts?.ready) {
      // @ts-ignore
      await document.fonts.ready;
    }
  } catch {}
}

async function loadB64Image(b64: string): Promise<HTMLImageElement | null> {
  if (!b64) return null;
  const src = b64.startsWith("data:image") ? b64 : `data:image/png;base64,${b64}`;
  return await new Promise((resolve) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = () => resolve(null);
    img.src = src;
  });
}

// ================== BoardSpec v1 (NEW) ==================
type BoardSpecV1 = {
  v: 1;
  layout: "split" | "full";
  title: string;
  left?: string[];
  right?: string[];
  diagram?: "pipeline" | "right_triangle" | "axes" | "none";
  centerLabel?: string;
  triangle?: { a?: string; b?: string; c?: string; formula?: string };
  axes?: { xLabel?: string; yLabel?: string; curveLabel?: string };
  image?: { enabled: boolean };
};

function tryParseBoardSpecV1(value: string): BoardSpecV1 | null {
  const t = (value || "").trim();
  if (!t.startsWith("{") || !t.endsWith("}")) return null;
  try {
    const obj = JSON.parse(t);
    if (!obj || typeof obj !== "object") return null;
    if (obj.v !== 1) return null;
    if (obj.layout !== "split" && obj.layout !== "full") return null;
    if (typeof obj.title !== "string") return null;
    return obj as BoardSpecV1;
  } catch {
    return null;
  }
}

// ================== Legacy (twoCol) ==================
type AutoBoard = {
  layout: "twoCol";
  title?: string;
  leftTitle?: string;
  rightTitle?: string;
  left?: string[];
  right?: string[];
  note?: string;
};

function tryParseAutoBoard(value: string): AutoBoard | null {
  const t = (value || "").trim();
  if (!t.startsWith("{") || !t.endsWith("}")) return null;
  try {
    const obj = JSON.parse(t);
    if (obj?.layout !== "twoCol") return null;
    return obj as AutoBoard;
  } catch {
    return null;
  }
}

// ================== COMPONENT ==================
export default function ChalkboardTutorBoard({
  value,
  className,
  backgroundSrc = "/boards/chalkboard-classic.webp",
  width = 1000,
  height = 600,
  boardImageB64 = null,
  boardImagePlacement = null,
}: Props) {
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const wrapRef = useRef<HTMLDivElement | null>(null);

  const [box, setBox] = useState({ w: 0, h: 0 });

  const imgCacheRef = useRef<{ b64: string | null; img: HTMLImageElement | null }>({ b64: null, img: null });

  const safeValue = useMemo(() => sanitizeBoardValue(value), [value]);

  const specV1 = useMemo(() => tryParseBoardSpecV1(safeValue), [safeValue]);
  const auto = useMemo(() => (specV1 ? null : tryParseAutoBoard(safeValue)), [safeValue, specV1]);

  // ✅ ResizeObserver: ahora medimos ancho y ALTO real del contenedor
  useEffect(() => {
    if (!wrapRef.current) return;
    const el = wrapRef.current;
    const ro = new ResizeObserver((entries) => {
      const cr = entries[0]?.contentRect;
      if (!cr) return;
      setBox({ w: Math.max(1, Math.floor(cr.width)), h: Math.max(1, Math.floor(cr.height)) });
    });
    ro.observe(el);
    return () => ro.disconnect();
  }, []);

  useEffect(() => {
    const c = canvasRef.current;
    if (!c) return;
    const ctx = c.getContext("2d");
    if (!ctx) return;

    const draw = async () => {
      await ensureFontsReady();

      // cache image
      let rightImg: HTMLImageElement | null = null;
      if (boardImageB64) {
        if (imgCacheRef.current.b64 !== boardImageB64) {
          imgCacheRef.current.b64 = boardImageB64;
          imgCacheRef.current.img = await loadB64Image(boardImageB64);
        }
        rightImg = imgCacheRef.current.img;
      } else {
        imgCacheRef.current.b64 = null;
        imgCacheRef.current.img = null;
      }

      const dpr = typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1;

      const dispW = box.w || width;
      const dispH = box.h || Math.round((dispW * height) / width);

      c.width = Math.floor(dispW * dpr);
      c.height = Math.floor(dispH * dpr);

      const sx = dispW / width;
      const sy = dispH / height;

      ctx.setTransform(dpr * sx, 0, 0, dpr * sy, 0, 0);
      ctx.clearRect(0, 0, width, height);

      // safe inset
      const INSET_X = 56;
      const INSET_Y = 44;
      const CLIP_W = width - INSET_X * 2;
      const CLIP_H = height - INSET_Y * 2;

      ctx.save();
      ctx.beginPath();
      ctx.rect(INSET_X, INSET_Y, CLIP_W, CLIP_H);
      ctx.clip();

      // optional image below everything
      if (rightImg && boardImagePlacement) {
        const { x, y, w, h } = boardImagePlacement;
        const xx = clamp(x, INSET_X, INSET_X + CLIP_W - 1);
        const yy = clamp(y, INSET_Y, INSET_Y + CLIP_H - 1);
        const ww = clamp(w, 1, INSET_X + CLIP_W - xx);
        const hh = clamp(h, 1, INSET_Y + CLIP_H - yy);

        ctx.save();
        ctx.globalAlpha = 0.98;
        ctx.shadowColor = "rgba(255,255,255,0.16)";
        ctx.shadowBlur = 0.9;
        ctx.drawImage(rightImg, xx, yy, ww, hh);
        ctx.restore();
      }

      // =========================
      // BoardSpec v1
      // =========================
      if (specV1) {
        const seed = hashStr(JSON.stringify(specV1));
        const rng = mulberry32(seed);

        const titleRaw = (specV1.title || "").trim();
        const title = titleRaw.length > 46 ? titleRaw.slice(0, 46) + "…" : titleRaw;

        const layout = specV1.layout;
        const left = Array.isArray(specV1.left) ? specV1.left.filter(Boolean).slice(0, 10) : [];
        const right = Array.isArray(specV1.right) ? specV1.right.filter(Boolean).slice(0, 10) : [];
        const diagram = specV1.diagram || "none";

        // ✅ título menos gigante (y más utilizable)
        const TITLE_SIZE = clamp(Math.round(48 - Math.max(0, title.length - 18) * 0.6), 34, 48);
        const H_SIZE = 30;
        const ITEM_SIZE = 30;

        const topY = INSET_Y + 16;
        let y = topY;

        if (title) {
          drawText(ctx, title.toUpperCase(), INSET_X + 16, y, TITLE_SIZE, COLOR_MAP.chalk, rng);
          const ulY = y + TITLE_SIZE + 6;
          drawWobblyLine(ctx, INSET_X + 16, ulY, INSET_X + 16 + Math.min(560, CLIP_W - 40), ulY, COLOR_MAP.yellow, 5, rng);
          y += TITLE_SIZE + 20;
        } else {
          y += 14;
        }

        const contentTop = y;
        const contentH = INSET_Y + CLIP_H - contentTop - 10;

        const gap = layout === "split" ? 54 : 0;
        const colW = layout === "split" ? (CLIP_W - gap) / 2 : CLIP_W;
        const leftX = INSET_X + 16;
        const rightX = INSET_X + colW + gap + 16;

        const leftTextMax = layout === "split" ? colW - 34 : CLIP_W * 0.48 - 30;
        const rightTextMax = layout === "split" ? colW - 34 : CLIP_W * 0.48 - 30;

        const drawList = (items: string[], x0: number, y0: number, maxW: number, color: string, bottomY: number) => {
          let yy = y0;
          for (const it of items) {
            const text = String(it || "").trim();
            if (!text) continue;

            ctx.save();
            setChalkFont(ctx, ITEM_SIZE);
            const lines = wrapText(ctx, text, maxW);
            ctx.restore();

            for (const line of lines.slice(0, 2)) {
              drawText(ctx, "• " + line, x0, yy, ITEM_SIZE, color, rng);
              yy += 36;
              if (yy > bottomY) return;
            }
            yy += 6;
            if (yy > bottomY) return;
          }
        };

        if (layout === "split") {
          drawText(ctx, "IZQ:", leftX, contentTop, H_SIZE, COLOR_MAP.white, rng);
          drawText(ctx, "DER:", rightX, contentTop, H_SIZE, COLOR_MAP.white, rng);

          const listY = contentTop + H_SIZE + 10;

          // diagram box reserved (to avoid overlaps)
          const diagBox =
            diagram === "none"
              ? null
              : {
                  x: rightX,
                  y: contentTop + 10 + Math.min(120, right.length * 34),
                  w: colW - 28,
                  h: Math.max(200, contentH - Math.min(120, right.length * 34) - 18),
                };

          const rightBottom = diagBox ? diagBox.y - 16 : contentTop + contentH - 10;
          drawList(left, leftX, listY, leftTextMax, COLOR_MAP.cyan, contentTop + contentH - 10);

          // clip for right list
          ctx.save();
          ctx.beginPath();
          ctx.rect(rightX, listY, colW - 20, rightBottom - listY);
          ctx.clip();
          drawList(right, rightX, listY, rightTextMax, COLOR_MAP.green, rightBottom);
          ctx.restore();

          // arrows between paired rows
          const rows = Math.min(left.length, right.length, 6);
          if (rows > 0) {
            const rowY0 = listY + 10;
            const rowH = 42;
            for (let i = 0; i < rows; i++) {
              const ay = rowY0 + i * rowH + 10;
              const ax1 = leftX + colW - 58;
              const ax2 = rightX - 16;
              drawArrow(ctx, ax1, ay, ax2, ay, COLOR_MAP.white, 4.6, rng);
            }
          }

          // diagrams
          if (diagBox) {
            const { x, y: dy, w: dw, h: dh } = diagBox;

            const drawBoxTitle = (label: string) => {
              drawText(ctx, label.toUpperCase(), x + 8, dy + 6, 26, COLOR_MAP.yellow, rng);
              const ulY = dy + 34;
              drawWobblyLine(ctx, x + 8, ulY, x + 8 + Math.min(dw - 18, 220), ulY, COLOR_MAP.yellow, 4, rng);
            };

            if (diagram === "right_triangle") {
              drawBoxTitle("Triángulo");

              const pad = 26;
              const bx = x + pad;
              const by = dy + 64;
              const bw = dw - pad * 2;
              const bh = dh - 86;

              const p1 = { x: bx, y: by + bh };
              const p2 = { x: bx + bw, y: by + bh };
              const p3 = { x: bx, y: by };

              drawWobblyLine(ctx, p1.x, p1.y, p2.x, p2.y, COLOR_MAP.white, 5, rng);
              drawWobblyLine(ctx, p1.x, p1.y, p3.x, p3.y, COLOR_MAP.white, 5, rng);
              drawWobblyLine(ctx, p3.x, p3.y, p2.x, p2.y, COLOR_MAP.white, 5, rng);

              const ra = 18;
              drawWobblyLine(ctx, p1.x, p1.y - ra, p1.x + ra, p1.y - ra, COLOR_MAP.yellow, 3.8, rng);
              drawWobblyLine(ctx, p1.x + ra, p1.y - ra, p1.x + ra, p1.y, COLOR_MAP.yellow, 3.8, rng);

              const a = fixSuperscripts(specV1.triangle?.a || "a");
              const b = fixSuperscripts(specV1.triangle?.b || "b");
              const cLab = fixSuperscripts(specV1.triangle?.c || "c");
              const formula = fixSuperscripts(specV1.triangle?.formula || "c² = a² + b²");

              drawText(ctx, b, (p1.x + p2.x) / 2 - 8, p1.y + 10, 26, COLOR_MAP.cyan, rng);
              drawText(ctx, a, p1.x - 22, (p1.y + p3.y) / 2 - 10, 26, COLOR_MAP.cyan, rng);
              drawText(ctx, cLab, (p3.x + p2.x) / 2 + 10, (p3.y + p2.y) / 2 - 18, 26, COLOR_MAP.green, rng);

              drawText(ctx, formula, x + 8, dy + dh - 36, 28, COLOR_MAP.green, rng);
            }
          }
        } else {
          // FULL layout (text left, diagram right)
          const textX = INSET_X + 16;
          const textW = CLIP_W * 0.48;
          const diagX = INSET_X + CLIP_W * 0.52;

          const centerLabel = (specV1.centerLabel || "").trim();
          if (centerLabel) drawText(ctx, centerLabel.toUpperCase(), textX, contentTop + 6, 30, COLOR_MAP.yellow, rng);

          const listsY = contentTop + (centerLabel ? 52 : 10);
          drawList(left.length ? left : right, textX, listsY, textW - 22, COLOR_MAP.white, contentTop + contentH - 10);

          if (diagram !== "none") {
            // leaving diagram impl for full as future, but safe
            drawText(ctx, "→ Mira el dibujo", diagX, contentTop + 10, 28, COLOR_MAP.green, rng);
          }
        }

        ctx.restore();
        return;
      }

      // =========================
      // Legacy: twoCol JSON
      // =========================
      if (auto?.layout === "twoCol") {
        const seed = hashStr(JSON.stringify(auto));
        const rng = mulberry32(seed);

        const title = fixSuperscripts((auto.title || "").trim());
        const leftTitle = (auto.leftTitle || "ENTRA").trim();
        const rightTitle = (auto.rightTitle || "SALE").trim();
        const left = Array.isArray(auto.left) ? auto.left.filter(Boolean).slice(0, 8).map(fixSuperscripts) : [];
        const right = Array.isArray(auto.right) ? auto.right.filter(Boolean).slice(0, 8).map(fixSuperscripts) : [];
        const note = fixSuperscripts((auto.note || "").trim());

        const TITLE_SIZE = 46;
        const H_SIZE = 32;
        const ITEM_SIZE = 30;

        const colGap = 54;
        const colW = (CLIP_W - colGap) / 2;
        const leftX = INSET_X + 16;
        const rightX = INSET_X + colW + colGap + 16;

        let y = INSET_Y + 16;

        if (title) {
          drawText(ctx, title.toUpperCase(), leftX, y, TITLE_SIZE, COLOR_MAP.white, rng);
          const ulY = y + TITLE_SIZE + 6;
          drawWobblyLine(ctx, leftX, ulY, leftX + Math.min(520, colW - 40), ulY, COLOR_MAP.yellow, 5, rng);
          y += TITLE_SIZE + 20;
        } else {
          y += 14;
        }

        drawText(ctx, leftTitle.toUpperCase() + ":", leftX, y, H_SIZE, COLOR_MAP.white, rng);
        drawText(ctx, rightTitle.toUpperCase() + ":", rightX, y, H_SIZE, COLOR_MAP.white, rng);
        y += H_SIZE + 12;

        const rows = Math.max(left.length, right.length, 1);
        const rowH = 44;

        for (let i = 0; i < rows; i++) {
          const ly = y + i * rowH;
          const ltxt = left[i] || "";
          const rtxt = right[i] || "";

          if (ltxt) drawText(ctx, ltxt, leftX, ly, ITEM_SIZE, COLOR_MAP.cyan, rng);
          if (rtxt) drawText(ctx, rtxt, rightX, ly, ITEM_SIZE, COLOR_MAP.green, rng);

          if (ltxt && rtxt) {
            const ax1 = leftX + colW - 52;
            const ax2 = rightX - 16;
            const ay = ly + 14;
            drawArrow(ctx, ax1, ay, ax2, ay, COLOR_MAP.white, 4.6, rng);
          }
        }

        if (note) {
          const ny = y + rows * rowH + 10;
          drawText(ctx, note, leftX, ny, 26, COLOR_MAP.white, rng);
        }

        ctx.restore();
        return;
      }

      // =========================
      // Fallback: texto suelto
      // =========================
      const baseSeed = hashStr(safeValue || "board");
      const r = mulberry32(baseSeed);

      let x = INSET_X + 16;
      let y = INSET_Y + 16;

      const lines = (safeValue || "")
        .split("\n")
        .map((l) => l.trimEnd())
        .filter(Boolean)
        .slice(0, 14);

      const title = lines[0] || "";
      if (title) {
        const T = clamp(48 - Math.max(0, title.length - 18) * 0.6, 34, 48);
        drawText(ctx, title.toUpperCase(), x, y, T, COLOR_MAP.white, r);
        const ulY = y + T + 6;
        drawWobblyLine(ctx, x, ulY, x + Math.min(560, CLIP_W - 40), ulY, COLOR_MAP.yellow, 5, r);
        y += T + 20;
      }

      for (let i = 1; i < lines.length; i++) {
        drawText(ctx, fixSuperscripts(lines[i]), x, y, 30, COLOR_MAP.white, r);
        y += 40;
      }

      ctx.restore();
    };

    draw();
  }, [safeValue, specV1, auto, width, height, box.w, box.h, boardImageB64, boardImagePlacement]);

  // ✅ CLAVE: el wrapper YA NO depende de la altura del <img>.
  // Ahora el <img> está ABSOLUTO y “cover”, y el tamaño lo decide el contenedor padre.
  return (
    <div className={className ?? ""}>
      <div ref={wrapRef} className="relative w-full h-full overflow-hidden rounded-[26px] border border-zinc-200 shadow-[0_18px_60px_rgba(0,0,0,0.10)]">
        <img
          src={backgroundSrc}
          alt="Pizarra"
          className="absolute inset-0 w-full h-full object-cover select-none pointer-events-none"
          draggable={false}
        />
        <canvas ref={canvasRef} className="absolute inset-0 w-full h-full" />
      </div>
    </div>
  );
}
